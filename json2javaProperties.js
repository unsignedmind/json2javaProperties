const fs = require('fs');
const path = require('path');
const trimStart = require('lodash.trimstart');
const trimEnd = require('lodash.trimend');

const inputPath = process.argv[3];
const outputPath = process.argv[2];
const fileList = fs.readdirSync(inputPath).filter((files) => files.endsWith('.json'));

fileList.forEach((filePath) => {
  const localeName = extractFileName(filePath);
  fs.readFile(path.normalize(`./translations/${filePath}`), 'utf8', (err, data) => {
    if (err) {
      console.log(err);
    }
    data = JSON.stringify(flattenJson(JSON.parse(data)), null, '\t');
    data = `# this file is autogenerated, please don't edit as these changes will be overwritten\n${json2javaProperties(data)}`;
    saveFile(localeName, data);
  });
});

function unicodeCharEscape(charCode) {
  return `\\u${charCode.toString(16).padStart(4, '0').toUpperCase()}`;
}

function unicodeEscape(string) {
  return string
    .split('')
    .map(function (char) {
      var charCode = char.charCodeAt(0);
      return charCode > 127 ? unicodeCharEscape(charCode) : char;
    })
    .join('');
}

/**
 *
 * @param fileName
 * @param data = formatted string
 */
function saveFile(fileName, data) {
  if (fileName !== '' && data !== '') {
    if (!fs.existsSync(outputPath)) {
      fs.mkdirSync(outputPath);
    }
    fs.writeFile(
      path.normalize(`${outputPath}${fileName}.properties`),
      data,
      { encoding: 'latin1' },
      (err) => {
        if (err) return console.log(err);
      },
    );
  }
}

function extractFileName(filePath) {
  const segments = filePath.split('/');
  return segments[segments.length - 1].replace('.json', '');
}

/**
 *
 * @param toBeFormatted flat stringified json
 * @returns {string} with line breaks in properties format
 */
function json2javaProperties(toBeFormatted) {
  // remove parenthese on start and end
  toBeFormatted = trimStart(toBeFormatted, '{');
  toBeFormatted = trimEnd(toBeFormatted, '}');
  // change value assignment
  toBeFormatted = toBeFormatted.split('": "').join('=');
  // remove comma at line end
  toBeFormatted = toBeFormatted.split('",').join('');
  // remove remaining quotation at end
  toBeFormatted = toBeFormatted.split('"\n').join('\n');
  // remove quote at start
  toBeFormatted = toBeFormatted
    .split('\n')
    .map((line) => line.slice(2))
    .join('\n');
  // remove empty lines in between
  toBeFormatted = toBeFormatted.split('\t').join('');
  // remove empty lines at the file start
  toBeFormatted = toBeFormatted.trim();
  return toBeFormatted
}

/**
 * Code is taken from https://stackoverflow.com/questions/19098797/fastest-way-to-flatten-un-flatten-nested-json-objects
 * Question Author: https://stackoverflow.com/users/884862/louis-ricci
 * @param data parsed JSON
 */
function flattenJson(data) {
  var result = {};

  function recurse(cur, prop) {
    if (Object(cur) !== cur) {
      result[prop] = cur;
    } else if (Array.isArray(cur)) {
      for (var i = 0, l = cur.length; i < l; i++) recurse(cur[i], `${prop}[${i}]`);
      if (l === 0) {
        result[prop] = [];
      }
    } else {
      let isEmpty = true;
      for (var p in cur) {
        isEmpty = false;
        recurse(cur[p], prop ? prop + '.' + p : p);
      }
      if (isEmpty && prop) {
        result[prop] = {};
      }
    }
  }
  recurse(data, '');
  return result;
}

